//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vhudson-jaxb-ri-2.1-833 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.06.17 at 01:24:02 PM BRT 
//


package org.cogroo.tools.checker.rules.model;

import java.io.Serializable;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlType;


/**
 * A mask for a tag
 * 
 * <p>Java class for TagMask complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="TagMask">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="SyntacticFunction" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="subject"/>
 *               &lt;enumeration value="verb"/>
 *               &lt;enumeration value="indirect object"/>
 *               &lt;enumeration value="direct object"/>
 *               &lt;enumeration value="subject predicative"/>
 *               &lt;enumeration value="subject predicative"/>
 *               &lt;enumeration value="identifying apposition"/>
 *               &lt;enumeration value="adverbial adjunct"/>
 *               &lt;enumeration value="none"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element name="ChunkFunction" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="boundary noun phrase"/>
 *               &lt;enumeration value="boundary noun phrase main"/>
 *               &lt;enumeration value="boundary verb phrase main"/>
 *               &lt;enumeration value="intermediary noun phrase"/>
 *               &lt;enumeration value="intermediary noun phrase main"/>
 *               &lt;enumeration value="intermediary verb phrase"/>
 *               &lt;enumeration value="other"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element name="Class" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="noun"/>
 *               &lt;enumeration value="noun adjective"/>
 *               &lt;enumeration value="proper noun"/>
 *               &lt;enumeration value="personal pronoun"/>
 *               &lt;enumeration value="pronoun"/>
 *               &lt;enumeration value="article"/>
 *               &lt;enumeration value="adjective"/>
 *               &lt;enumeration value="adverb"/>
 *               &lt;enumeration value="infinitive verb"/>
 *               &lt;enumeration value="numeral"/>
 *               &lt;enumeration value="subordinating conjunction"/>
 *               &lt;enumeration value="coordinating conjunction"/>
 *               &lt;enumeration value="interjection"/>
 *               &lt;enumeration value="prefix"/>
 *               &lt;enumeration value="preposition"/>
 *               &lt;enumeration value="punctuation mark"/>
 *               &lt;enumeration value="finitive verb"/>
 *               &lt;enumeration value="participle verb"/>
 *               &lt;enumeration value="gerund verb"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element name="Gender" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="male"/>
 *               &lt;enumeration value="female"/>
 *               &lt;enumeration value="neutral"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element name="Number" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="singular"/>
 *               &lt;enumeration value="plural"/>
 *               &lt;enumeration value="neutral"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element name="Case" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="nominative"/>
 *               &lt;enumeration value="accusative"/>
 *               &lt;enumeration value="dative"/>
 *               &lt;enumeration value="prepositive"/>
 *               &lt;enumeration value="accusative-dative"/>
 *               &lt;enumeration value="nominative-prepositive"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element name="Person" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="first"/>
 *               &lt;enumeration value="second"/>
 *               &lt;enumeration value="third"/>
 *               &lt;enumeration value="first-third"/>
 *               &lt;enumeration value="none-first-third"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element name="Tense" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="present"/>
 *               &lt;enumeration value="preterito imperfeito"/>
 *               &lt;enumeration value="preterito perfeito"/>
 *               &lt;enumeration value="preterito mais-que-perfeito"/>
 *               &lt;enumeration value="future"/>
 *               &lt;enumeration value="conditional"/>
 *               &lt;enumeration value="preterito perfeito-mais-que-perfeito"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element name="Mood" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="indicative"/>
 *               &lt;enumeration value="subjunctive"/>
 *               &lt;enumeration value="imperative"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element name="Punctuation" minOccurs="0">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="abs"/>
 *               &lt;enumeration value="nsep"/>
 *               &lt;enumeration value="bin"/>
 *               &lt;enumeration value="rel"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "TagMask", propOrder = {
    "syntacticFunction",
    "chunkFunction",
    "clazz",
    "gender",
    "number",
    "_case",
    "person",
    "tense",
    "mood",
    "punctuation"
})
public class TagMask
    implements Serializable
{

    private final static long serialVersionUID = 1L;
    @XmlElement(name = "SyntacticFunction")
    protected TagMask.SyntacticFunction syntacticFunction;
    @XmlElement(name = "ChunkFunction")
    protected TagMask.ChunkFunction chunkFunction;
    @XmlElement(name = "Class")
    protected TagMask.Class clazz;
    @XmlElement(name = "Gender")
    protected TagMask.Gender gender;
    @XmlElement(name = "Number")
    protected TagMask.Number number;
    @XmlElement(name = "Case")
    protected TagMask.Case _case;
    @XmlElement(name = "Person")
    protected TagMask.Person person;
    @XmlElement(name = "Tense")
    protected TagMask.Tense tense;
    @XmlElement(name = "Mood")
    protected TagMask.Mood mood;
    @XmlElement(name = "Punctuation")
    protected TagMask.Punctuation punctuation;

    /**
     * Gets the value of the syntacticFunction property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.SyntacticFunction }
     *     
     */
    public TagMask.SyntacticFunction getSyntacticFunction() {
        return syntacticFunction;
    }

    /**
     * Sets the value of the syntacticFunction property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.SyntacticFunction }
     *     
     */
    public void setSyntacticFunction(TagMask.SyntacticFunction value) {
        this.syntacticFunction = value;
    }

    /**
     * Gets the value of the chunkFunction property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.ChunkFunction }
     *     
     */
    public TagMask.ChunkFunction getChunkFunction() {
        return chunkFunction;
    }

    /**
     * Sets the value of the chunkFunction property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.ChunkFunction }
     *     
     */
    public void setChunkFunction(TagMask.ChunkFunction value) {
        this.chunkFunction = value;
    }

    /**
     * Gets the value of the clazz property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.Class }
     *     
     */
    public TagMask.Class getClazz() {
        return clazz;
    }

    /**
     * Sets the value of the clazz property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.Class }
     *     
     */
    public void setClazz(TagMask.Class value) {
        this.clazz = value;
    }

    /**
     * Gets the value of the gender property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.Gender }
     *     
     */
    public TagMask.Gender getGender() {
        return gender;
    }

    /**
     * Sets the value of the gender property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.Gender }
     *     
     */
    public void setGender(TagMask.Gender value) {
        this.gender = value;
    }

    /**
     * Gets the value of the number property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.Number }
     *     
     */
    public TagMask.Number getNumber() {
        return number;
    }

    /**
     * Sets the value of the number property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.Number }
     *     
     */
    public void setNumber(TagMask.Number value) {
        this.number = value;
    }

    /**
     * Gets the value of the case property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.Case }
     *     
     */
    public TagMask.Case getCase() {
        return _case;
    }

    /**
     * Sets the value of the case property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.Case }
     *     
     */
    public void setCase(TagMask.Case value) {
        this._case = value;
    }

    /**
     * Gets the value of the person property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.Person }
     *     
     */
    public TagMask.Person getPerson() {
        return person;
    }

    /**
     * Sets the value of the person property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.Person }
     *     
     */
    public void setPerson(TagMask.Person value) {
        this.person = value;
    }

    /**
     * Gets the value of the tense property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.Tense }
     *     
     */
    public TagMask.Tense getTense() {
        return tense;
    }

    /**
     * Sets the value of the tense property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.Tense }
     *     
     */
    public void setTense(TagMask.Tense value) {
        this.tense = value;
    }

    /**
     * Gets the value of the mood property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.Mood }
     *     
     */
    public TagMask.Mood getMood() {
        return mood;
    }

    /**
     * Sets the value of the mood property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.Mood }
     *     
     */
    public void setMood(TagMask.Mood value) {
        this.mood = value;
    }

    /**
     * Gets the value of the punctuation property.
     * 
     * @return
     *     possible object is
     *     {@link TagMask.Punctuation }
     *     
     */
    public TagMask.Punctuation getPunctuation() {
        return punctuation;
    }

    /**
     * Sets the value of the punctuation property.
     * 
     * @param value
     *     allowed object is
     *     {@link TagMask.Punctuation }
     *     
     */
    public void setPunctuation(TagMask.Punctuation value) {
        this.punctuation = value;
    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="nominative"/>
     *     &lt;enumeration value="accusative"/>
     *     &lt;enumeration value="dative"/>
     *     &lt;enumeration value="prepositive"/>
     *     &lt;enumeration value="accusative-dative"/>
     *     &lt;enumeration value="nominative-prepositive"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum Case {

        @XmlEnumValue("nominative")
        NOMINATIVE("nominative"),
        @XmlEnumValue("accusative")
        ACCUSATIVE("accusative"),
        @XmlEnumValue("dative")
        DATIVE("dative"),
        @XmlEnumValue("prepositive")
        PREPOSITIVE("prepositive"),
        @XmlEnumValue("accusative-dative")
        ACCUSATIVE_DATIVE("accusative-dative"),
        @XmlEnumValue("nominative-prepositive")
        NOMINATIVE_PREPOSITIVE("nominative-prepositive");
        private final String value;

        Case(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.Case fromValue(String v) {
            for (TagMask.Case c: TagMask.Case.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="boundary noun phrase"/>
     *     &lt;enumeration value="boundary noun phrase main"/>
     *     &lt;enumeration value="boundary verb phrase main"/>
     *     &lt;enumeration value="intermediary noun phrase"/>
     *     &lt;enumeration value="intermediary noun phrase main"/>
     *     &lt;enumeration value="intermediary verb phrase"/>
     *     &lt;enumeration value="other"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum ChunkFunction {

        @XmlEnumValue("boundary noun phrase")
        BOUNDARY_NOUN_PHRASE("boundary noun phrase"),
        @XmlEnumValue("boundary noun phrase main")
        BOUNDARY_NOUN_PHRASE_MAIN("boundary noun phrase main"),
        @XmlEnumValue("boundary verb phrase main")
        BOUNDARY_VERB_PHRASE_MAIN("boundary verb phrase main"),
        @XmlEnumValue("intermediary noun phrase")
        INTERMEDIARY_NOUN_PHRASE("intermediary noun phrase"),
        @XmlEnumValue("intermediary noun phrase main")
        INTERMEDIARY_NOUN_PHRASE_MAIN("intermediary noun phrase main"),
        @XmlEnumValue("intermediary verb phrase")
        INTERMEDIARY_VERB_PHRASE("intermediary verb phrase"),
        @XmlEnumValue("other")
        OTHER("other");
        private final String value;

        ChunkFunction(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.ChunkFunction fromValue(String v) {
            for (TagMask.ChunkFunction c: TagMask.ChunkFunction.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="noun"/>
     *     &lt;enumeration value="noun adjective"/>
     *     &lt;enumeration value="proper noun"/>
     *     &lt;enumeration value="personal pronoun"/>
     *     &lt;enumeration value="pronoun"/>
     *     &lt;enumeration value="article"/>
     *     &lt;enumeration value="adjective"/>
     *     &lt;enumeration value="adverb"/>
     *     &lt;enumeration value="infinitive verb"/>
     *     &lt;enumeration value="numeral"/>
     *     &lt;enumeration value="subordinating conjunction"/>
     *     &lt;enumeration value="coordinating conjunction"/>
     *     &lt;enumeration value="interjection"/>
     *     &lt;enumeration value="prefix"/>
     *     &lt;enumeration value="preposition"/>
     *     &lt;enumeration value="punctuation mark"/>
     *     &lt;enumeration value="finitive verb"/>
     *     &lt;enumeration value="participle verb"/>
     *     &lt;enumeration value="gerund verb"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum Class {

        @XmlEnumValue("noun")
        NOUN("noun"),
        @XmlEnumValue("noun adjective")
        NOUN_ADJECTIVE("noun adjective"),
        @XmlEnumValue("proper noun")
        PROPER_NOUN("proper noun"),
        @XmlEnumValue("personal pronoun")
        PERSONAL_PRONOUN("personal pronoun"),
        @XmlEnumValue("pronoun")
        PRONOUN("pronoun"),
        @XmlEnumValue("article")
        ARTICLE("article"),
        @XmlEnumValue("adjective")
        ADJECTIVE("adjective"),
        @XmlEnumValue("adverb")
        ADVERB("adverb"),
        @XmlEnumValue("infinitive verb")
        INFINITIVE_VERB("infinitive verb"),
        @XmlEnumValue("numeral")
        NUMERAL("numeral"),
        @XmlEnumValue("subordinating conjunction")
        SUBORDINATING_CONJUNCTION("subordinating conjunction"),
        @XmlEnumValue("coordinating conjunction")
        COORDINATING_CONJUNCTION("coordinating conjunction"),
        @XmlEnumValue("interjection")
        INTERJECTION("interjection"),
        @XmlEnumValue("prefix")
        PREFIX("prefix"),
        @XmlEnumValue("preposition")
        PREPOSITION("preposition"),
        @XmlEnumValue("punctuation mark")
        PUNCTUATION_MARK("punctuation mark"),
        @XmlEnumValue("finitive verb")
        FINITIVE_VERB("finitive verb"),
        @XmlEnumValue("participle verb")
        PARTICIPLE_VERB("participle verb"),
        @XmlEnumValue("gerund verb")
        GERUND_VERB("gerund verb");
        private final String value;

        Class(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.Class fromValue(String v) {
            for (TagMask.Class c: TagMask.Class.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="male"/>
     *     &lt;enumeration value="female"/>
     *     &lt;enumeration value="neutral"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum Gender {

        @XmlEnumValue("male")
        MALE("male"),
        @XmlEnumValue("female")
        FEMALE("female"),
        @XmlEnumValue("neutral")
        NEUTRAL("neutral");
        private final String value;

        Gender(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.Gender fromValue(String v) {
            for (TagMask.Gender c: TagMask.Gender.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="indicative"/>
     *     &lt;enumeration value="subjunctive"/>
     *     &lt;enumeration value="imperative"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum Mood {

        @XmlEnumValue("indicative")
        INDICATIVE("indicative"),
        @XmlEnumValue("subjunctive")
        SUBJUNCTIVE("subjunctive"),
        @XmlEnumValue("imperative")
        IMPERATIVE("imperative");
        private final String value;

        Mood(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.Mood fromValue(String v) {
            for (TagMask.Mood c: TagMask.Mood.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="singular"/>
     *     &lt;enumeration value="plural"/>
     *     &lt;enumeration value="neutral"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum Number {

        @XmlEnumValue("singular")
        SINGULAR("singular"),
        @XmlEnumValue("plural")
        PLURAL("plural"),
        @XmlEnumValue("neutral")
        NEUTRAL("neutral");
        private final String value;

        Number(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.Number fromValue(String v) {
            for (TagMask.Number c: TagMask.Number.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="first"/>
     *     &lt;enumeration value="second"/>
     *     &lt;enumeration value="third"/>
     *     &lt;enumeration value="first-third"/>
     *     &lt;enumeration value="none-first-third"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum Person {

        @XmlEnumValue("first")
        FIRST("first"),
        @XmlEnumValue("second")
        SECOND("second"),
        @XmlEnumValue("third")
        THIRD("third"),
        @XmlEnumValue("first-third")
        FIRST_THIRD("first-third"),
        @XmlEnumValue("none-first-third")
        NONE_FIRST_THIRD("none-first-third");
        private final String value;

        Person(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.Person fromValue(String v) {
            for (TagMask.Person c: TagMask.Person.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="abs"/>
     *     &lt;enumeration value="nsep"/>
     *     &lt;enumeration value="bin"/>
     *     &lt;enumeration value="rel"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum Punctuation {

        @XmlEnumValue("abs")
        ABS("abs"),
        @XmlEnumValue("nsep")
        NSEP("nsep"),
        @XmlEnumValue("bin")
        BIN("bin"),
        @XmlEnumValue("rel")
        REL("rel");
        private final String value;

        Punctuation(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.Punctuation fromValue(String v) {
            for (TagMask.Punctuation c: TagMask.Punctuation.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="subject"/>
     *     &lt;enumeration value="verb"/>
     *     &lt;enumeration value="indirect object"/>
     *     &lt;enumeration value="direct object"/>
     *     &lt;enumeration value="subject predicative"/>
     *     &lt;enumeration value="subject predicative"/>
     *     &lt;enumeration value="identifying apposition"/>
     *     &lt;enumeration value="adverbial adjunct"/>
     *     &lt;enumeration value="none"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum SyntacticFunction {

        @XmlEnumValue("subject")
        SUBJECT("subject"),
        @XmlEnumValue("verb")
        VERB("verb"),
        @XmlEnumValue("indirect object")
        INDIRECT_OBJECT("indirect object"),
        @XmlEnumValue("direct object")
        DIRECT_OBJECT("direct object"),
        @XmlEnumValue("subject predicative")
        SUBJECT_PREDICATIVE("subject predicative"),
        @XmlEnumValue("identifying apposition")
        IDENTIFYING_APPOSITION("identifying apposition"),
        @XmlEnumValue("adverbial adjunct")
        ADVERBIAL_ADJUNCT("adverbial adjunct"),
        @XmlEnumValue("none")
        NONE("none");
        private final String value;

        SyntacticFunction(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.SyntacticFunction fromValue(String v) {
            for (TagMask.SyntacticFunction c: TagMask.SyntacticFunction.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }


    /**
     * <p>Java class for null.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * <p>
     * <pre>
     * &lt;simpleType>
     *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *     &lt;enumeration value="present"/>
     *     &lt;enumeration value="preterito imperfeito"/>
     *     &lt;enumeration value="preterito perfeito"/>
     *     &lt;enumeration value="preterito mais-que-perfeito"/>
     *     &lt;enumeration value="future"/>
     *     &lt;enumeration value="conditional"/>
     *     &lt;enumeration value="preterito perfeito-mais-que-perfeito"/>
     *   &lt;/restriction>
     * &lt;/simpleType>
     * </pre>
     * 
     */
    @XmlType(name = "")
    @XmlEnum
    public enum Tense {

        @XmlEnumValue("present")
        PRESENT("present"),
        @XmlEnumValue("preterito imperfeito")
        PRETERITO_IMPERFEITO("preterito imperfeito"),
        @XmlEnumValue("preterito perfeito")
        PRETERITO_PERFEITO("preterito perfeito"),
        @XmlEnumValue("preterito mais-que-perfeito")
        PRETERITO_MAIS_QUE_PERFEITO("preterito mais-que-perfeito"),
        @XmlEnumValue("future")
        FUTURE("future"),
        @XmlEnumValue("conditional")
        CONDITIONAL("conditional"),
        @XmlEnumValue("preterito perfeito-mais-que-perfeito")
        PRETERITO_PERFEITO_MAIS_QUE_PERFEITO("preterito perfeito-mais-que-perfeito");
        private final String value;

        Tense(String v) {
            value = v;
        }

        public String value() {
            return value;
        }

        public static TagMask.Tense fromValue(String v) {
            for (TagMask.Tense c: TagMask.Tense.values()) {
                if (c.value.equals(v)) {
                    return c;
                }
            }
            throw new IllegalArgumentException(v);
        }

    }

}
