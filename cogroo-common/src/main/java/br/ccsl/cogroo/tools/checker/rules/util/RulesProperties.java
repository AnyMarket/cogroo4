/**
 * Copyright (C) 2008 CoGrOO Team (cogroo AT gmail DOT com)
 * 
 * CoGrOO Team (cogroo AT gmail DOT com)
 * LTA, PCS (Computer and Digital Systems Engineering Department),
 * Escola Politécnica da Universidade de São Paulo
 * Av. Prof. Luciano Gualberto, trav. 3, n. 380
 * CEP 05508-900 - São Paulo - SP - BRAZIL
 * 
 * http://cogroo.sourceforge.net/
 * 
 * This file is part of CoGrOO.
 * 
 * CoGrOO is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public as published by 
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * CoGrOO is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with CoGrOO. If not, see <http://www.gnu.org/licenses/>.
 */

package br.ccsl.cogroo.tools.checker.rules.util;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import br.ccsl.cogroo.tools.checker.rules.applier.RulesTreesBuilder;
import br.ccsl.cogroo.tools.checker.rules.applier.RulesXmlAccess;

/**
 * This class holds common properties to the rules applier classes.
 * 
 * @author Marcelo Suzumura
 * @version $Id: RulesProperties.java 400 2007-04-19 02:36:40Z msuzumura $
 */
public class RulesProperties {

	/**
	 * This resource bundle holds various properties used by the rules applier.
	 */
	//public static final ResourceBundle RESOURCES = ResourceBundle.getBundle("br.ccsl.cogroo.tools.checker.rules.rules");

	public static String rootFolder = System.getProperty("user.dir") + "/";
	
	/**
	 * Types of trees that will be generated by the {@link RulesTreesBuilder} class, based in the schema and
	 * the rules.
	 */
	public static final int NUMBER_OF_TREES = 3;

	/**
	 * Index of the tree that matches rules in the tokens level.
	 */
	public static final int GENERAL_TREE = 0;

	/**
	 * Index of the tree that matches rules in the chunks level.
	 */
	public static final int PHRASE_LOCAL_TREE = 1;

	/**
	 * Index of the tree that matches rules between the subject and verb.
	 */
	public static final int SUBJECT_VERB_TREE = 2;
	
	//private static final ResourceBundle PROPERTIES = ResourceBundle.getBundle("br.ccsl.cogroo.tools.checker.rules.rules");
	private static final Properties PROPERTIES = new Properties();
	
  static {
    try {
      InputStream stream = RulesProperties.class.getResourceAsStream("/rules/properties/rules.properties");
      PROPERTIES.load(stream);
      stream.close();
    } catch (IOException e) {
      throw new RuntimeException("could not load rules.properties!", e);
    }
  }

	public static final String PACKAGE = getString("package");
	
	private static String SCHEMA = getString("schema");
	
	private static boolean READ_FROM_SERIALIZED = getBoolean("read.from.serialized");
	
	public static final boolean REREAD_FROM_SERIALIZED = getBoolean("reread.from.serialized");
		
	public static final String DATA_SOURCE = getString("data.source");
	
	private static boolean REREAD_RULES = getBoolean("reread.rules");
	
	public static final String XML_FILE_ENCODING = getString("xml.file.encoding");
	
	private static String XML_FILE = getStringPathWithRoot("xml.file");
	
	public static final String[] CHECKERS = getCommaSeparatedString("checkers");
	
	/**
	 * This resets all paths!
	 * @param value
	 */
	public static void setRootFolder(String value) {
		rootFolder = value + "/";
		
		setRulesFile(getStringPathWithRoot("xml.file"));
		setSchemaFile(getStringPathWithRoot("schema"));
		//setRulesFile(prependWithRoot(getRulesFile()));
		//setSchemaFile(prependWithRoot(getSchemaFile()));
		
		//setSerializedTreesFile(getStringPathWithRoot("serialized.trees.file"));
		
	}
	
	private static String[] getCommaSeparatedString(String string) {
		String[] prop = getString(string).split(",");
		return prop;
	}

	private static boolean getBoolean(String key) {
		return Boolean.parseBoolean(PROPERTIES.getProperty(key));
	}

	private static String getString(String key) {
		return PROPERTIES.getProperty(key);
	}
	
	private static String getStringPathWithRoot(String key) {
		return prependWithRoot(getString(key));
	}
	
	private static String prependWithRoot(String value) {
		if(rootFolder == null)
			rootFolder = System.getProperty("user.dir") + "/";
		return rootFolder + value;
	}

	/**
	 * Private constructor which prevents this class instantiation.
	 */
	private RulesProperties() {
		// Prevents instantiation.
	}
	
	public static void setRulesFile(String rulesFile) {
		XML_FILE = rulesFile;
	}
	
	public static void setSchemaFile(String schemaFile) {
		SCHEMA = schemaFile;
	}

	public static String getRulesFile() {
		return XML_FILE;
	}
	
	public static String getSchemaFile() {
		return SCHEMA;
	}

	public static String getSerializedTreesFile() {
		return getRulesFile() + ".tree";
	}

	public static void setRereadRules(boolean rereadRules) {
		REREAD_RULES = rereadRules;
	}

	public static boolean isRereadRules() {
		return REREAD_RULES;
	}

	public static void setReadFromSerialized(boolean readFromSerialized) {
		READ_FROM_SERIALIZED = readFromSerialized;
	}

	public static boolean isReadFromSerialized() {
		return READ_FROM_SERIALIZED;
	}

}
